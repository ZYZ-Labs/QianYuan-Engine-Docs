# 智能协调层协议与 API 文档

本文档描述了 QianYuan Engine 智能协调层与边缘设备之间的通信协议，包括基于 TCP 的自有协议消息格式以及用于管理和监控调度的 HTTP API 接口。本文档旨在为开发团队提供统一的协议规范和接口定义，确保各模块之间高效、低延迟地交换任务和状态数据。

---

## 1. 总体概述

### 1.1 目标

- **低延迟任务调度与反馈：**  
  基于 TCP 自有协议实现快速的任务下发、状态上报和执行结果反馈。

- **系统管理与监控：**  
  通过 HTTP API 提供任务管理、系统状态查询和调度监控等功能，便于配置、调试和运维。

### 1.2 通信架构

- **TCP 通信：**  
  用于实时、低延迟的任务下发和状态反馈，采用自定义二进制协议，保证数据包简洁高效。

- **HTTP 接口：**  
  用于管理、配置和监控，通过 RESTful API 提供较为灵活的交互方式，数据格式采用 JSON。

---

## 2. TCP 自有协议

### 2.1 消息结构

TCP 自有协议的消息采用二进制格式，整体分为消息头和消息体两部分。

#### 消息头格式

| 字段         | 长度      | 说明                                   |
| ------------ | --------- | -------------------------------------- |
| 消息类型     | 1 字节    | 标识消息种类：<br>0x01：任务下发<br>0x02：状态上报<br>0x03：任务执行结果<br>其他自定义类型 |
| 任务 ID      | 16 字节   | 使用 UUID 标识任务或设备（可选，用于状态消息和反馈关联） |
| 数据长度     | 4 字节    | 消息体数据的字节长度                   |

> **说明：**  
> - 所有多字节字段建议采用网络字节序（big-endian）。  
> - 任务 ID 字段可固定为设备标识或动态任务 ID，根据具体消息类型定义。

#### 消息体格式

消息体采用二进制数据，根据消息类型不同，采用不同的序列化结构。建议采用轻量化二进制序列化方式，例如通过 `struct` 格式进行打包。

### 2.2 常见消息示例

#### 2.2.1 任务下发消息

- **消息类型：** 0x01  
- **消息体结构：**  
  - 任务参数（例如，任务类型、执行参数等），建议定义固定格式，如：
    - 任务类型（1 字节）
    - 参数1（4 字节，整数/浮点数）
    - 参数2（4 字节，整数/浮点数）
    - ...

#### 2.2.2 状态上报消息

- **消息类型：** 0x02  
- **消息体结构示例：**

| 字段         | 长度   | 说明                      |
| ------------ | ------ | ------------------------- |
| CPU 使用率   | 4 字节 | 浮点数表示，如 0.35       |
| 内存使用率   | 4 字节 | 浮点数表示，如 0.60       |
| 时间戳       | 8 字节 | 时间戳（Unix 时间），可选  |

**示例伪代码（Python）：**

```python
import struct
import uuid
import time

def create_status_report(cpu_usage, mem_usage):
    msg_type = 0x02
    # 使用设备ID或固定标识符，这里用随机 UUID 示例
    task_id = uuid.uuid4().bytes  
    # 将 cpu_usage 和 mem_usage 转换为浮点数（4字节），时间戳（8字节）
    payload = struct.pack('ffQ', cpu_usage, mem_usage, int(time.time()))
    data_length = len(payload)
    # 构造消息头：B 表示 1 字节，16s 表示 16 字节字符串，I 表示无符号整型 4 字节
    header = struct.pack('!B16sI', msg_type, task_id, data_length)
    return header + payload

status_message = create_status_report(0.35, 0.60)
```

#### 2.2.3 任务执行结果消息

- **消息类型：** 0x03
- 消息体结构：
  - 任务结果（可自定义格式），例如：
    - 执行状态（1 字节，成功/失败标识）
    - 结果数据（例如 4 字节整数/浮点数）
    - 其他调试信息（可选）

------

## 3. HTTP API 接口

HTTP 接口主要用于任务管理、系统状态查询以及调度监控等管理功能。数据格式均采用 JSON。

### 3.1 基本 API 设计原则

- 使用 RESTful 风格，HTTP 方法对应操作类型：
  - **GET**：查询操作
  - **POST**：创建任务、下发指令
  - **PUT/PATCH**：更新配置
  - **DELETE**：删除任务或记录
- 所有接口均应返回统一格式的响应，建议格式如下：

```json
{
  "status": "success", 
  "data": { ... },
  "message": "Optional message"
}
```

### 3.2 示例接口

#### 3.2.1 任务下发接口

**URL：** `/dispatch_task`
 **方法：** POST
 **请求示例：**

```json
{
  "task_details": {
    "task_type": "compute_square",
    "parameters": {
      "number": 5
    }
  }
}
```

**响应示例：**

```json
{
  "status": "success",
  "data": {
    "task_id": "a1b2c3d4-e5f6-7890-1234-56789abcdef0",
    "timestamp": 1680000000
  },
  "message": "Task dispatched successfully."
}
```

#### 3.2.2 系统状态查询接口

**URL：** `/system_status`
 **方法：** GET
 **功能：** 返回当前调度器状态、连接的边缘设备信息、资源使用情况等。
 **响应示例：**

```json
{
  "status": "success",
  "data": {
    "connected_devices": 12,
    "average_cpu_usage": 0.45,
    "average_mem_usage": 0.55,
    "pending_tasks": 3
  },
  "message": ""
}
```

#### 3.2.3 配置更新接口

**URL：** `/update_config`
 **方法：** PUT
 **请求示例：**

```json
{
  "config": {
    "max_task_timeout": 5000,
    "retry_attempts": 3
  }
}
```

**响应示例：**

```json
{
  "status": "success",
  "data": {},
  "message": "Configuration updated."
}
```

------

## 4. 安全性考虑

- **数据完整性：**
   虽然考虑到家庭设备的性能和实际应用场景，目前阶段我们不强制要求对 TCP 通信数据进行加密，但必须实现数据完整性校验，确保数据在传输过程中未被篡改。例如，可采用简单的校验和或哈希校验方法验证消息内容。
- **硬件性能考量：**
   由于家庭设备性能有限，采用复杂的加密算法可能会导致额外性能开销，因此在初期设计中，我们优先保证低延迟和高效任务调度，暂时取消数据加密的需求。
- **HTTP API 接口：**
   由于涉及管理和监控数据传输，建议 HTTP 接口在生产环境下使用 HTTPS 进行数据保护。对于调度层内部的低延迟通信，重点放在完整性校验而非加密上。

------

## 5. 版本与扩展

- 当前文档描述的是初始版本协议，后续将根据项目需求和调研反馈扩展更多消息类型和接口功能。
- 各模块开发时，请严格按照本协议和 API 规范进行实现，必要时对接口进行版本管理。

------

> *注：本协议与 API 文档为初始版本，后续将根据实际开发和性能测试结果不断更新和完善。*